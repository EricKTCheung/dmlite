// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MemcacheCatalog.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace dmlite {

namespace {

const ::google::protobuf::Descriptor* SerialExtendedStat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialExtendedStat_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialStat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialStat_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialSymLink_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialSymLink_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialComment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialComment_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialKeyList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialKeyList_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialReplicaList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialReplicaList_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialReplica_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialReplica_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CacheState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_MemcacheCatalog_2eproto() {
  protobuf_AddDesc_MemcacheCatalog_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "MemcacheCatalog.proto");
  GOOGLE_CHECK(file != NULL);
  SerialExtendedStat_descriptor_ = file->message_type(0);
  static const int SerialExtendedStat_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, stat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, parent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, csumtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, csumvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, acl_),
  };
  SerialExtendedStat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialExtendedStat_descriptor_,
      SerialExtendedStat::default_instance_,
      SerialExtendedStat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialExtendedStat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialExtendedStat));
  SerialStat_descriptor_ = file->message_type(1);
  static const int SerialStat_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_dev_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_ino_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_nlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_gid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_rdev_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_access_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_modified_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_change_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_blksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, st_blocks_),
  };
  SerialStat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialStat_descriptor_,
      SerialStat::default_instance_,
      SerialStat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialStat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialStat));
  SerialSymLink_descriptor_ = file->message_type(2);
  static const int SerialSymLink_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialSymLink, fileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialSymLink, link_),
  };
  SerialSymLink_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialSymLink_descriptor_,
      SerialSymLink::default_instance_,
      SerialSymLink_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialSymLink, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialSymLink, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialSymLink));
  SerialComment_descriptor_ = file->message_type(3);
  static const int SerialComment_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialComment, comment_),
  };
  SerialComment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialComment_descriptor_,
      SerialComment::default_instance_,
      SerialComment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialComment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialComment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialComment));
  SerialKeyList_descriptor_ = file->message_type(4);
  static const int SerialKeyList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKeyList, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKeyList, key_),
  };
  SerialKeyList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialKeyList_descriptor_,
      SerialKeyList::default_instance_,
      SerialKeyList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKeyList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKeyList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialKeyList));
  SerialKey_descriptor_ = file->message_type(5);
  static const int SerialKey_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKey, key_),
  };
  SerialKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialKey_descriptor_,
      SerialKey::default_instance_,
      SerialKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialKey));
  SerialReplicaList_descriptor_ = file->message_type(6);
  static const int SerialReplicaList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplicaList, replica_),
  };
  SerialReplicaList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialReplicaList_descriptor_,
      SerialReplicaList::default_instance_,
      SerialReplicaList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplicaList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplicaList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialReplicaList));
  SerialReplica_descriptor_ = file->message_type(7);
  static const int SerialReplica_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, replicaid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, fileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, nbaccesses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, atime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, ptime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, ltime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, pool_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, server_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, filesystem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, url_),
  };
  SerialReplica_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialReplica_descriptor_,
      SerialReplica::default_instance_,
      SerialReplica_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialReplica, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialReplica));
  CacheState_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_MemcacheCatalog_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialExtendedStat_descriptor_, &SerialExtendedStat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialStat_descriptor_, &SerialStat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialSymLink_descriptor_, &SerialSymLink::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialComment_descriptor_, &SerialComment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialKeyList_descriptor_, &SerialKeyList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialKey_descriptor_, &SerialKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialReplicaList_descriptor_, &SerialReplicaList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialReplica_descriptor_, &SerialReplica::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_MemcacheCatalog_2eproto() {
  delete SerialExtendedStat::default_instance_;
  delete SerialExtendedStat_reflection_;
  delete SerialStat::default_instance_;
  delete SerialStat_reflection_;
  delete SerialSymLink::default_instance_;
  delete SerialSymLink_reflection_;
  delete SerialComment::default_instance_;
  delete SerialComment_reflection_;
  delete SerialKeyList::default_instance_;
  delete SerialKeyList_reflection_;
  delete SerialKey::default_instance_;
  delete SerialKey_reflection_;
  delete SerialReplicaList::default_instance_;
  delete SerialReplicaList_reflection_;
  delete SerialReplica::default_instance_;
  delete SerialReplica_reflection_;
}

void protobuf_AddDesc_MemcacheCatalog_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025MemcacheCatalog.proto\022\006dmlite\"\262\001\n\022Seri"
    "alExtendedStat\022 \n\004stat\030\001 \001(\0132\022.dmlite.Se"
    "rialStat\022\016\n\006parent\030\002 \001(\005\022\014\n\004type\030\003 \001(\005\022\016"
    "\n\006status\030\004 \001(\t\022\014\n\004name\030\005 \001(\t\022\014\n\004guid\030\006 \001"
    "(\t\022\020\n\010csumtype\030\007 \001(\t\022\021\n\tcsumvalue\030\010 \001(\t\022"
    "\013\n\003acl\030\t \001(\t\"\202\002\n\nSerialStat\022\016\n\006st_dev\030\001 "
    "\001(\005\022\016\n\006st_ino\030\002 \001(\005\022\017\n\007st_mode\030\003 \001(\005\022\020\n\010"
    "st_nlink\030\004 \001(\005\022\016\n\006st_uid\030\005 \001(\005\022\016\n\006st_gid"
    "\030\006 \001(\005\022\017\n\007st_rdev\030\007 \001(\005\022\017\n\007st_size\030\010 \001(\005"
    "\022\026\n\016st_access_time\030\t \001(\003\022\030\n\020st_modified_"
    "time\030\n \001(\003\022\026\n\016st_change_time\030\013 \001(\003\022\022\n\nst"
    "_blksize\030\014 \001(\005\022\021\n\tst_blocks\030\r \001(\005\"-\n\rSer"
    "ialSymLink\022\016\n\006fileid\030\001 \001(\005\022\014\n\004link\030\002 \001(\t"
    "\" \n\rSerialComment\022\017\n\007comment\030\001 \001(\t\"[\n\rSe"
    "rialKeyList\022*\n\005state\030\002 \002(\0162\022.dmlite.Cach"
    "eState:\007MISSING\022\036\n\003key\030\001 \003(\0132\021.dmlite.Se"
    "rialKey\"\030\n\tSerialKey\022\013\n\003key\030\001 \002(\t\";\n\021Ser"
    "ialReplicaList\022&\n\007replica\030\001 \003(\0132\025.dmlite"
    ".SerialReplica\"\320\001\n\rSerialReplica\022\021\n\trepl"
    "icaid\030\001 \001(\003\022\016\n\006fileid\030\002 \001(\003\022\022\n\nnbaccesse"
    "s\030\003 \001(\003\022\r\n\005atime\030\004 \001(\003\022\r\n\005ptime\030\005 \001(\003\022\r\n"
    "\005ltime\030\006 \001(\003\022\016\n\006status\030\007 \001(\t\022\014\n\004type\030\010 \001"
    "(\t\022\014\n\004pool\030\t \001(\t\022\016\n\006server\030\n \001(\t\022\022\n\nfile"
    "system\030\013 \001(\t\022\013\n\003url\030\014 \001(\t*1\n\nCacheState\022"
    "\013\n\007MISSING\020\000\022\013\n\007INVALID\020\001\022\t\n\005VALID\020\002", 996);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "MemcacheCatalog.proto", &protobuf_RegisterTypes);
  SerialExtendedStat::default_instance_ = new SerialExtendedStat();
  SerialStat::default_instance_ = new SerialStat();
  SerialSymLink::default_instance_ = new SerialSymLink();
  SerialComment::default_instance_ = new SerialComment();
  SerialKeyList::default_instance_ = new SerialKeyList();
  SerialKey::default_instance_ = new SerialKey();
  SerialReplicaList::default_instance_ = new SerialReplicaList();
  SerialReplica::default_instance_ = new SerialReplica();
  SerialExtendedStat::default_instance_->InitAsDefaultInstance();
  SerialStat::default_instance_->InitAsDefaultInstance();
  SerialSymLink::default_instance_->InitAsDefaultInstance();
  SerialComment::default_instance_->InitAsDefaultInstance();
  SerialKeyList::default_instance_->InitAsDefaultInstance();
  SerialKey::default_instance_->InitAsDefaultInstance();
  SerialReplicaList::default_instance_->InitAsDefaultInstance();
  SerialReplica::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MemcacheCatalog_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MemcacheCatalog_2eproto {
  StaticDescriptorInitializer_MemcacheCatalog_2eproto() {
    protobuf_AddDesc_MemcacheCatalog_2eproto();
  }
} static_descriptor_initializer_MemcacheCatalog_2eproto_;

const ::google::protobuf::EnumDescriptor* CacheState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CacheState_descriptor_;
}
bool CacheState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::std::string SerialExtendedStat::_default_status_;
const ::std::string SerialExtendedStat::_default_name_;
const ::std::string SerialExtendedStat::_default_guid_;
const ::std::string SerialExtendedStat::_default_csumtype_;
const ::std::string SerialExtendedStat::_default_csumvalue_;
const ::std::string SerialExtendedStat::_default_acl_;
#ifndef _MSC_VER
const int SerialExtendedStat::kStatFieldNumber;
const int SerialExtendedStat::kParentFieldNumber;
const int SerialExtendedStat::kTypeFieldNumber;
const int SerialExtendedStat::kStatusFieldNumber;
const int SerialExtendedStat::kNameFieldNumber;
const int SerialExtendedStat::kGuidFieldNumber;
const int SerialExtendedStat::kCsumtypeFieldNumber;
const int SerialExtendedStat::kCsumvalueFieldNumber;
const int SerialExtendedStat::kAclFieldNumber;
#endif  // !_MSC_VER

SerialExtendedStat::SerialExtendedStat()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialExtendedStat::InitAsDefaultInstance() {
  stat_ = const_cast< ::dmlite::SerialStat*>(&::dmlite::SerialStat::default_instance());
}

SerialExtendedStat::SerialExtendedStat(const SerialExtendedStat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialExtendedStat::SharedCtor() {
  _cached_size_ = 0;
  stat_ = NULL;
  parent_ = 0;
  type_ = 0;
  status_ = const_cast< ::std::string*>(&_default_status_);
  name_ = const_cast< ::std::string*>(&_default_name_);
  guid_ = const_cast< ::std::string*>(&_default_guid_);
  csumtype_ = const_cast< ::std::string*>(&_default_csumtype_);
  csumvalue_ = const_cast< ::std::string*>(&_default_csumvalue_);
  acl_ = const_cast< ::std::string*>(&_default_acl_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialExtendedStat::~SerialExtendedStat() {
  SharedDtor();
}

void SerialExtendedStat::SharedDtor() {
  if (status_ != &_default_status_) {
    delete status_;
  }
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (guid_ != &_default_guid_) {
    delete guid_;
  }
  if (csumtype_ != &_default_csumtype_) {
    delete csumtype_;
  }
  if (csumvalue_ != &_default_csumvalue_) {
    delete csumvalue_;
  }
  if (acl_ != &_default_acl_) {
    delete acl_;
  }
  if (this != default_instance_) {
    delete stat_;
  }
}

void SerialExtendedStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialExtendedStat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialExtendedStat_descriptor_;
}

const SerialExtendedStat& SerialExtendedStat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialExtendedStat* SerialExtendedStat::default_instance_ = NULL;

SerialExtendedStat* SerialExtendedStat::New() const {
  return new SerialExtendedStat;
}

void SerialExtendedStat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (stat_ != NULL) stat_->::dmlite::SerialStat::Clear();
    }
    parent_ = 0;
    type_ = 0;
    if (_has_bit(3)) {
      if (status_ != &_default_status_) {
        status_->clear();
      }
    }
    if (_has_bit(4)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(5)) {
      if (guid_ != &_default_guid_) {
        guid_->clear();
      }
    }
    if (_has_bit(6)) {
      if (csumtype_ != &_default_csumtype_) {
        csumtype_->clear();
      }
    }
    if (_has_bit(7)) {
      if (csumvalue_ != &_default_csumvalue_) {
        csumvalue_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (acl_ != &_default_acl_) {
        acl_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialExtendedStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .dmlite.SerialStat stat = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_parent;
        break;
      }
      
      // optional int32 parent = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &parent_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }
      
      // optional int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_status;
        break;
      }
      
      // optional string status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }
      
      // optional string name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_guid;
        break;
      }
      
      // optional string guid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->guid().data(), this->guid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_csumtype;
        break;
      }
      
      // optional string csumtype = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_csumtype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_csumtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->csumtype().data(), this->csumtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_csumvalue;
        break;
      }
      
      // optional string csumvalue = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_csumvalue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_csumvalue()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->csumvalue().data(), this->csumvalue().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_acl;
        break;
      }
      
      // optional string acl = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_acl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->acl().data(), this->acl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialExtendedStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .dmlite.SerialStat stat = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stat(), output);
  }
  
  // optional int32 parent = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->parent(), output);
  }
  
  // optional int32 type = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }
  
  // optional string status = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->status(), output);
  }
  
  // optional string name = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->name(), output);
  }
  
  // optional string guid = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guid().data(), this->guid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->guid(), output);
  }
  
  // optional string csumtype = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->csumtype().data(), this->csumtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->csumtype(), output);
  }
  
  // optional string csumvalue = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->csumvalue().data(), this->csumvalue().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->csumvalue(), output);
  }
  
  // optional string acl = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->acl().data(), this->acl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->acl(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialExtendedStat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .dmlite.SerialStat stat = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stat(), target);
  }
  
  // optional int32 parent = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->parent(), target);
  }
  
  // optional int32 type = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->type(), target);
  }
  
  // optional string status = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->status(), target);
  }
  
  // optional string name = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->name(), target);
  }
  
  // optional string guid = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guid().data(), this->guid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->guid(), target);
  }
  
  // optional string csumtype = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->csumtype().data(), this->csumtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->csumtype(), target);
  }
  
  // optional string csumvalue = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->csumvalue().data(), this->csumvalue().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->csumvalue(), target);
  }
  
  // optional string acl = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->acl().data(), this->acl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->acl(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialExtendedStat::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .dmlite.SerialStat stat = 1;
    if (has_stat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stat());
    }
    
    // optional int32 parent = 2;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->parent());
    }
    
    // optional int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // optional string status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string guid = 6;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
    // optional string csumtype = 7;
    if (has_csumtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->csumtype());
    }
    
    // optional string csumvalue = 8;
    if (has_csumvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->csumvalue());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string acl = 9;
    if (has_acl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->acl());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialExtendedStat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialExtendedStat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialExtendedStat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialExtendedStat::MergeFrom(const SerialExtendedStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_stat()->::dmlite::SerialStat::MergeFrom(from.stat());
    }
    if (from._has_bit(1)) {
      set_parent(from.parent());
    }
    if (from._has_bit(2)) {
      set_type(from.type());
    }
    if (from._has_bit(3)) {
      set_status(from.status());
    }
    if (from._has_bit(4)) {
      set_name(from.name());
    }
    if (from._has_bit(5)) {
      set_guid(from.guid());
    }
    if (from._has_bit(6)) {
      set_csumtype(from.csumtype());
    }
    if (from._has_bit(7)) {
      set_csumvalue(from.csumvalue());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_acl(from.acl());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialExtendedStat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialExtendedStat::CopyFrom(const SerialExtendedStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialExtendedStat::IsInitialized() const {
  
  return true;
}

void SerialExtendedStat::Swap(SerialExtendedStat* other) {
  if (other != this) {
    std::swap(stat_, other->stat_);
    std::swap(parent_, other->parent_);
    std::swap(type_, other->type_);
    std::swap(status_, other->status_);
    std::swap(name_, other->name_);
    std::swap(guid_, other->guid_);
    std::swap(csumtype_, other->csumtype_);
    std::swap(csumvalue_, other->csumvalue_);
    std::swap(acl_, other->acl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialExtendedStat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialExtendedStat_descriptor_;
  metadata.reflection = SerialExtendedStat_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SerialStat::kStDevFieldNumber;
const int SerialStat::kStInoFieldNumber;
const int SerialStat::kStModeFieldNumber;
const int SerialStat::kStNlinkFieldNumber;
const int SerialStat::kStUidFieldNumber;
const int SerialStat::kStGidFieldNumber;
const int SerialStat::kStRdevFieldNumber;
const int SerialStat::kStSizeFieldNumber;
const int SerialStat::kStAccessTimeFieldNumber;
const int SerialStat::kStModifiedTimeFieldNumber;
const int SerialStat::kStChangeTimeFieldNumber;
const int SerialStat::kStBlksizeFieldNumber;
const int SerialStat::kStBlocksFieldNumber;
#endif  // !_MSC_VER

SerialStat::SerialStat()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialStat::InitAsDefaultInstance() {
}

SerialStat::SerialStat(const SerialStat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialStat::SharedCtor() {
  _cached_size_ = 0;
  st_dev_ = 0;
  st_ino_ = 0;
  st_mode_ = 0;
  st_nlink_ = 0;
  st_uid_ = 0;
  st_gid_ = 0;
  st_rdev_ = 0;
  st_size_ = 0;
  st_access_time_ = GOOGLE_LONGLONG(0);
  st_modified_time_ = GOOGLE_LONGLONG(0);
  st_change_time_ = GOOGLE_LONGLONG(0);
  st_blksize_ = 0;
  st_blocks_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialStat::~SerialStat() {
  SharedDtor();
}

void SerialStat::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SerialStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialStat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialStat_descriptor_;
}

const SerialStat& SerialStat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialStat* SerialStat::default_instance_ = NULL;

SerialStat* SerialStat::New() const {
  return new SerialStat;
}

void SerialStat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    st_dev_ = 0;
    st_ino_ = 0;
    st_mode_ = 0;
    st_nlink_ = 0;
    st_uid_ = 0;
    st_gid_ = 0;
    st_rdev_ = 0;
    st_size_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    st_access_time_ = GOOGLE_LONGLONG(0);
    st_modified_time_ = GOOGLE_LONGLONG(0);
    st_change_time_ = GOOGLE_LONGLONG(0);
    st_blksize_ = 0;
    st_blocks_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 st_dev = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_dev_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_st_ino;
        break;
      }
      
      // optional int32 st_ino = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_ino:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_ino_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_st_mode;
        break;
      }
      
      // optional int32 st_mode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_mode_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_st_nlink;
        break;
      }
      
      // optional int32 st_nlink = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_nlink:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_nlink_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_st_uid;
        break;
      }
      
      // optional int32 st_uid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_uid_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_st_gid;
        break;
      }
      
      // optional int32 st_gid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_gid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_gid_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_st_rdev;
        break;
      }
      
      // optional int32 st_rdev = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_rdev:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_rdev_)));
          _set_bit(6);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_st_size;
        break;
      }
      
      // optional int32 st_size = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_size_)));
          _set_bit(7);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_st_access_time;
        break;
      }
      
      // optional int64 st_access_time = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_access_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &st_access_time_)));
          _set_bit(8);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_st_modified_time;
        break;
      }
      
      // optional int64 st_modified_time = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_modified_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &st_modified_time_)));
          _set_bit(9);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_st_change_time;
        break;
      }
      
      // optional int64 st_change_time = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_change_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &st_change_time_)));
          _set_bit(10);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_st_blksize;
        break;
      }
      
      // optional int32 st_blksize = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_blksize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_blksize_)));
          _set_bit(11);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_st_blocks;
        break;
      }
      
      // optional int32 st_blocks = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_st_blocks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &st_blocks_)));
          _set_bit(12);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 st_dev = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->st_dev(), output);
  }
  
  // optional int32 st_ino = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->st_ino(), output);
  }
  
  // optional int32 st_mode = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->st_mode(), output);
  }
  
  // optional int32 st_nlink = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->st_nlink(), output);
  }
  
  // optional int32 st_uid = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->st_uid(), output);
  }
  
  // optional int32 st_gid = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->st_gid(), output);
  }
  
  // optional int32 st_rdev = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->st_rdev(), output);
  }
  
  // optional int32 st_size = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->st_size(), output);
  }
  
  // optional int64 st_access_time = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->st_access_time(), output);
  }
  
  // optional int64 st_modified_time = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->st_modified_time(), output);
  }
  
  // optional int64 st_change_time = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->st_change_time(), output);
  }
  
  // optional int32 st_blksize = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->st_blksize(), output);
  }
  
  // optional int32 st_blocks = 13;
  if (_has_bit(12)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->st_blocks(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialStat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 st_dev = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->st_dev(), target);
  }
  
  // optional int32 st_ino = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->st_ino(), target);
  }
  
  // optional int32 st_mode = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->st_mode(), target);
  }
  
  // optional int32 st_nlink = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->st_nlink(), target);
  }
  
  // optional int32 st_uid = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->st_uid(), target);
  }
  
  // optional int32 st_gid = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->st_gid(), target);
  }
  
  // optional int32 st_rdev = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->st_rdev(), target);
  }
  
  // optional int32 st_size = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->st_size(), target);
  }
  
  // optional int64 st_access_time = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->st_access_time(), target);
  }
  
  // optional int64 st_modified_time = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->st_modified_time(), target);
  }
  
  // optional int64 st_change_time = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->st_change_time(), target);
  }
  
  // optional int32 st_blksize = 12;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->st_blksize(), target);
  }
  
  // optional int32 st_blocks = 13;
  if (_has_bit(12)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->st_blocks(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialStat::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 st_dev = 1;
    if (has_st_dev()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_dev());
    }
    
    // optional int32 st_ino = 2;
    if (has_st_ino()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_ino());
    }
    
    // optional int32 st_mode = 3;
    if (has_st_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_mode());
    }
    
    // optional int32 st_nlink = 4;
    if (has_st_nlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_nlink());
    }
    
    // optional int32 st_uid = 5;
    if (has_st_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_uid());
    }
    
    // optional int32 st_gid = 6;
    if (has_st_gid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_gid());
    }
    
    // optional int32 st_rdev = 7;
    if (has_st_rdev()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_rdev());
    }
    
    // optional int32 st_size = 8;
    if (has_st_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_size());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 st_access_time = 9;
    if (has_st_access_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->st_access_time());
    }
    
    // optional int64 st_modified_time = 10;
    if (has_st_modified_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->st_modified_time());
    }
    
    // optional int64 st_change_time = 11;
    if (has_st_change_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->st_change_time());
    }
    
    // optional int32 st_blksize = 12;
    if (has_st_blksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_blksize());
    }
    
    // optional int32 st_blocks = 13;
    if (has_st_blocks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->st_blocks());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialStat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialStat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialStat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialStat::MergeFrom(const SerialStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_st_dev(from.st_dev());
    }
    if (from._has_bit(1)) {
      set_st_ino(from.st_ino());
    }
    if (from._has_bit(2)) {
      set_st_mode(from.st_mode());
    }
    if (from._has_bit(3)) {
      set_st_nlink(from.st_nlink());
    }
    if (from._has_bit(4)) {
      set_st_uid(from.st_uid());
    }
    if (from._has_bit(5)) {
      set_st_gid(from.st_gid());
    }
    if (from._has_bit(6)) {
      set_st_rdev(from.st_rdev());
    }
    if (from._has_bit(7)) {
      set_st_size(from.st_size());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_st_access_time(from.st_access_time());
    }
    if (from._has_bit(9)) {
      set_st_modified_time(from.st_modified_time());
    }
    if (from._has_bit(10)) {
      set_st_change_time(from.st_change_time());
    }
    if (from._has_bit(11)) {
      set_st_blksize(from.st_blksize());
    }
    if (from._has_bit(12)) {
      set_st_blocks(from.st_blocks());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialStat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialStat::CopyFrom(const SerialStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialStat::IsInitialized() const {
  
  return true;
}

void SerialStat::Swap(SerialStat* other) {
  if (other != this) {
    std::swap(st_dev_, other->st_dev_);
    std::swap(st_ino_, other->st_ino_);
    std::swap(st_mode_, other->st_mode_);
    std::swap(st_nlink_, other->st_nlink_);
    std::swap(st_uid_, other->st_uid_);
    std::swap(st_gid_, other->st_gid_);
    std::swap(st_rdev_, other->st_rdev_);
    std::swap(st_size_, other->st_size_);
    std::swap(st_access_time_, other->st_access_time_);
    std::swap(st_modified_time_, other->st_modified_time_);
    std::swap(st_change_time_, other->st_change_time_);
    std::swap(st_blksize_, other->st_blksize_);
    std::swap(st_blocks_, other->st_blocks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialStat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialStat_descriptor_;
  metadata.reflection = SerialStat_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SerialSymLink::_default_link_;
#ifndef _MSC_VER
const int SerialSymLink::kFileidFieldNumber;
const int SerialSymLink::kLinkFieldNumber;
#endif  // !_MSC_VER

SerialSymLink::SerialSymLink()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialSymLink::InitAsDefaultInstance() {
}

SerialSymLink::SerialSymLink(const SerialSymLink& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialSymLink::SharedCtor() {
  _cached_size_ = 0;
  fileid_ = 0;
  link_ = const_cast< ::std::string*>(&_default_link_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialSymLink::~SerialSymLink() {
  SharedDtor();
}

void SerialSymLink::SharedDtor() {
  if (link_ != &_default_link_) {
    delete link_;
  }
  if (this != default_instance_) {
  }
}

void SerialSymLink::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialSymLink::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialSymLink_descriptor_;
}

const SerialSymLink& SerialSymLink::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialSymLink* SerialSymLink::default_instance_ = NULL;

SerialSymLink* SerialSymLink::New() const {
  return new SerialSymLink;
}

void SerialSymLink::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fileid_ = 0;
    if (_has_bit(1)) {
      if (link_ != &_default_link_) {
        link_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialSymLink::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 fileid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fileid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_link;
        break;
      }
      
      // optional string link = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_link:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->link().data(), this->link().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialSymLink::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 fileid = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->fileid(), output);
  }
  
  // optional string link = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->link().data(), this->link().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->link(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialSymLink::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 fileid = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->fileid(), target);
  }
  
  // optional string link = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->link().data(), this->link().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialSymLink::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 fileid = 1;
    if (has_fileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fileid());
    }
    
    // optional string link = 2;
    if (has_link()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->link());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialSymLink::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialSymLink* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialSymLink*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialSymLink::MergeFrom(const SerialSymLink& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_fileid(from.fileid());
    }
    if (from._has_bit(1)) {
      set_link(from.link());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialSymLink::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialSymLink::CopyFrom(const SerialSymLink& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialSymLink::IsInitialized() const {
  
  return true;
}

void SerialSymLink::Swap(SerialSymLink* other) {
  if (other != this) {
    std::swap(fileid_, other->fileid_);
    std::swap(link_, other->link_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialSymLink::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialSymLink_descriptor_;
  metadata.reflection = SerialSymLink_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SerialComment::_default_comment_;
#ifndef _MSC_VER
const int SerialComment::kCommentFieldNumber;
#endif  // !_MSC_VER

SerialComment::SerialComment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialComment::InitAsDefaultInstance() {
}

SerialComment::SerialComment(const SerialComment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialComment::SharedCtor() {
  _cached_size_ = 0;
  comment_ = const_cast< ::std::string*>(&_default_comment_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialComment::~SerialComment() {
  SharedDtor();
}

void SerialComment::SharedDtor() {
  if (comment_ != &_default_comment_) {
    delete comment_;
  }
  if (this != default_instance_) {
  }
}

void SerialComment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialComment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialComment_descriptor_;
}

const SerialComment& SerialComment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialComment* SerialComment::default_instance_ = NULL;

SerialComment* SerialComment::New() const {
  return new SerialComment;
}

void SerialComment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (comment_ != &_default_comment_) {
        comment_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialComment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comment = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->comment().data(), this->comment().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialComment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string comment = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->comment(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialComment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string comment = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->comment(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialComment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string comment = 1;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialComment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialComment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialComment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialComment::MergeFrom(const SerialComment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_comment(from.comment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialComment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialComment::CopyFrom(const SerialComment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialComment::IsInitialized() const {
  
  return true;
}

void SerialComment::Swap(SerialComment* other) {
  if (other != this) {
    std::swap(comment_, other->comment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialComment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialComment_descriptor_;
  metadata.reflection = SerialComment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SerialKeyList::kStateFieldNumber;
const int SerialKeyList::kKeyFieldNumber;
#endif  // !_MSC_VER

SerialKeyList::SerialKeyList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialKeyList::InitAsDefaultInstance() {
}

SerialKeyList::SerialKeyList(const SerialKeyList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialKeyList::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialKeyList::~SerialKeyList() {
  SharedDtor();
}

void SerialKeyList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SerialKeyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialKeyList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialKeyList_descriptor_;
}

const SerialKeyList& SerialKeyList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialKeyList* SerialKeyList::default_instance_ = NULL;

SerialKeyList* SerialKeyList::New() const {
  return new SerialKeyList;
}

void SerialKeyList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
  }
  key_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialKeyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .dmlite.SerialKey key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key;
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }
      
      // required .dmlite.CacheState state = 2 [default = MISSING];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (dmlite::CacheState_IsValid(value)) {
            set_state(static_cast< dmlite::CacheState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialKeyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .dmlite.SerialKey key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->key(i), output);
  }
  
  // required .dmlite.CacheState state = 2 [default = MISSING];
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialKeyList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .dmlite.SerialKey key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->key(i), target);
  }
  
  // required .dmlite.CacheState state = 2 [default = MISSING];
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialKeyList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .dmlite.CacheState state = 2 [default = MISSING];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }
    
  }
  // repeated .dmlite.SerialKey key = 1;
  total_size += 1 * this->key_size();
  for (int i = 0; i < this->key_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialKeyList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialKeyList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialKeyList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialKeyList::MergeFrom(const SerialKeyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_.MergeFrom(from.key_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialKeyList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialKeyList::CopyFrom(const SerialKeyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialKeyList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < key_size(); i++) {
    if (!this->key(i).IsInitialized()) return false;
  }
  return true;
}

void SerialKeyList::Swap(SerialKeyList* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    key_.Swap(&other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialKeyList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialKeyList_descriptor_;
  metadata.reflection = SerialKeyList_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SerialKey::_default_key_;
#ifndef _MSC_VER
const int SerialKey::kKeyFieldNumber;
#endif  // !_MSC_VER

SerialKey::SerialKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialKey::InitAsDefaultInstance() {
}

SerialKey::SerialKey(const SerialKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialKey::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&_default_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialKey::~SerialKey() {
  SharedDtor();
}

void SerialKey::SharedDtor() {
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void SerialKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialKey_descriptor_;
}

const SerialKey& SerialKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialKey* SerialKey::default_instance_ = NULL;

SerialKey* SerialKey::New() const {
  return new SerialKey;
}

void SerialKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialKey::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialKey::MergeFrom(const SerialKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialKey::CopyFrom(const SerialKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void SerialKey::Swap(SerialKey* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialKey_descriptor_;
  metadata.reflection = SerialKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SerialReplicaList::kReplicaFieldNumber;
#endif  // !_MSC_VER

SerialReplicaList::SerialReplicaList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialReplicaList::InitAsDefaultInstance() {
}

SerialReplicaList::SerialReplicaList(const SerialReplicaList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialReplicaList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialReplicaList::~SerialReplicaList() {
  SharedDtor();
}

void SerialReplicaList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SerialReplicaList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialReplicaList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialReplicaList_descriptor_;
}

const SerialReplicaList& SerialReplicaList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialReplicaList* SerialReplicaList::default_instance_ = NULL;

SerialReplicaList* SerialReplicaList::New() const {
  return new SerialReplicaList;
}

void SerialReplicaList::Clear() {
  replica_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialReplicaList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .dmlite.SerialReplica replica = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_replica:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_replica()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_replica;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialReplicaList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .dmlite.SerialReplica replica = 1;
  for (int i = 0; i < this->replica_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->replica(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialReplicaList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .dmlite.SerialReplica replica = 1;
  for (int i = 0; i < this->replica_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->replica(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialReplicaList::ByteSize() const {
  int total_size = 0;
  
  // repeated .dmlite.SerialReplica replica = 1;
  total_size += 1 * this->replica_size();
  for (int i = 0; i < this->replica_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->replica(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialReplicaList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialReplicaList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialReplicaList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialReplicaList::MergeFrom(const SerialReplicaList& from) {
  GOOGLE_CHECK_NE(&from, this);
  replica_.MergeFrom(from.replica_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialReplicaList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialReplicaList::CopyFrom(const SerialReplicaList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialReplicaList::IsInitialized() const {
  
  return true;
}

void SerialReplicaList::Swap(SerialReplicaList* other) {
  if (other != this) {
    replica_.Swap(&other->replica_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialReplicaList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialReplicaList_descriptor_;
  metadata.reflection = SerialReplicaList_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SerialReplica::_default_status_;
const ::std::string SerialReplica::_default_type_;
const ::std::string SerialReplica::_default_pool_;
const ::std::string SerialReplica::_default_server_;
const ::std::string SerialReplica::_default_filesystem_;
const ::std::string SerialReplica::_default_url_;
#ifndef _MSC_VER
const int SerialReplica::kReplicaidFieldNumber;
const int SerialReplica::kFileidFieldNumber;
const int SerialReplica::kNbaccessesFieldNumber;
const int SerialReplica::kAtimeFieldNumber;
const int SerialReplica::kPtimeFieldNumber;
const int SerialReplica::kLtimeFieldNumber;
const int SerialReplica::kStatusFieldNumber;
const int SerialReplica::kTypeFieldNumber;
const int SerialReplica::kPoolFieldNumber;
const int SerialReplica::kServerFieldNumber;
const int SerialReplica::kFilesystemFieldNumber;
const int SerialReplica::kUrlFieldNumber;
#endif  // !_MSC_VER

SerialReplica::SerialReplica()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SerialReplica::InitAsDefaultInstance() {
}

SerialReplica::SerialReplica(const SerialReplica& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SerialReplica::SharedCtor() {
  _cached_size_ = 0;
  replicaid_ = GOOGLE_LONGLONG(0);
  fileid_ = GOOGLE_LONGLONG(0);
  nbaccesses_ = GOOGLE_LONGLONG(0);
  atime_ = GOOGLE_LONGLONG(0);
  ptime_ = GOOGLE_LONGLONG(0);
  ltime_ = GOOGLE_LONGLONG(0);
  status_ = const_cast< ::std::string*>(&_default_status_);
  type_ = const_cast< ::std::string*>(&_default_type_);
  pool_ = const_cast< ::std::string*>(&_default_pool_);
  server_ = const_cast< ::std::string*>(&_default_server_);
  filesystem_ = const_cast< ::std::string*>(&_default_filesystem_);
  url_ = const_cast< ::std::string*>(&_default_url_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialReplica::~SerialReplica() {
  SharedDtor();
}

void SerialReplica::SharedDtor() {
  if (status_ != &_default_status_) {
    delete status_;
  }
  if (type_ != &_default_type_) {
    delete type_;
  }
  if (pool_ != &_default_pool_) {
    delete pool_;
  }
  if (server_ != &_default_server_) {
    delete server_;
  }
  if (filesystem_ != &_default_filesystem_) {
    delete filesystem_;
  }
  if (url_ != &_default_url_) {
    delete url_;
  }
  if (this != default_instance_) {
  }
}

void SerialReplica::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialReplica::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialReplica_descriptor_;
}

const SerialReplica& SerialReplica::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MemcacheCatalog_2eproto();  return *default_instance_;
}

SerialReplica* SerialReplica::default_instance_ = NULL;

SerialReplica* SerialReplica::New() const {
  return new SerialReplica;
}

void SerialReplica::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    replicaid_ = GOOGLE_LONGLONG(0);
    fileid_ = GOOGLE_LONGLONG(0);
    nbaccesses_ = GOOGLE_LONGLONG(0);
    atime_ = GOOGLE_LONGLONG(0);
    ptime_ = GOOGLE_LONGLONG(0);
    ltime_ = GOOGLE_LONGLONG(0);
    if (_has_bit(6)) {
      if (status_ != &_default_status_) {
        status_->clear();
      }
    }
    if (_has_bit(7)) {
      if (type_ != &_default_type_) {
        type_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (pool_ != &_default_pool_) {
        pool_->clear();
      }
    }
    if (_has_bit(9)) {
      if (server_ != &_default_server_) {
        server_->clear();
      }
    }
    if (_has_bit(10)) {
      if (filesystem_ != &_default_filesystem_) {
        filesystem_->clear();
      }
    }
    if (_has_bit(11)) {
      if (url_ != &_default_url_) {
        url_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialReplica::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 replicaid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &replicaid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fileid;
        break;
      }
      
      // optional int64 fileid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fileid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fileid_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nbaccesses;
        break;
      }
      
      // optional int64 nbaccesses = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nbaccesses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &nbaccesses_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_atime;
        break;
      }
      
      // optional int64 atime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_atime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &atime_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ptime;
        break;
      }
      
      // optional int64 ptime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ptime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ptime_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ltime;
        break;
      }
      
      // optional int64 ltime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ltime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ltime_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_status;
        break;
      }
      
      // optional string status = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_type;
        break;
      }
      
      // optional string type = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_pool;
        break;
      }
      
      // optional string pool = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pool:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pool()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pool().data(), this->pool().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_server;
        break;
      }
      
      // optional string server = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_filesystem;
        break;
      }
      
      // optional string filesystem = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filesystem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filesystem()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filesystem().data(), this->filesystem().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_url;
        break;
      }
      
      // optional string url = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->url().data(), this->url().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SerialReplica::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 replicaid = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->replicaid(), output);
  }
  
  // optional int64 fileid = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->fileid(), output);
  }
  
  // optional int64 nbaccesses = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->nbaccesses(), output);
  }
  
  // optional int64 atime = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->atime(), output);
  }
  
  // optional int64 ptime = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->ptime(), output);
  }
  
  // optional int64 ltime = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->ltime(), output);
  }
  
  // optional string status = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->status(), output);
  }
  
  // optional string type = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->type(), output);
  }
  
  // optional string pool = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pool().data(), this->pool().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->pool(), output);
  }
  
  // optional string server = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->server(), output);
  }
  
  // optional string filesystem = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filesystem().data(), this->filesystem().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->filesystem(), output);
  }
  
  // optional string url = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->url(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SerialReplica::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 replicaid = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->replicaid(), target);
  }
  
  // optional int64 fileid = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->fileid(), target);
  }
  
  // optional int64 nbaccesses = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->nbaccesses(), target);
  }
  
  // optional int64 atime = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->atime(), target);
  }
  
  // optional int64 ptime = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->ptime(), target);
  }
  
  // optional int64 ltime = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->ltime(), target);
  }
  
  // optional string status = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->status(), target);
  }
  
  // optional string type = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->type(), target);
  }
  
  // optional string pool = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pool().data(), this->pool().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->pool(), target);
  }
  
  // optional string server = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->server(), target);
  }
  
  // optional string filesystem = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filesystem().data(), this->filesystem().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->filesystem(), target);
  }
  
  // optional string url = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->url(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SerialReplica::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 replicaid = 1;
    if (has_replicaid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->replicaid());
    }
    
    // optional int64 fileid = 2;
    if (has_fileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fileid());
    }
    
    // optional int64 nbaccesses = 3;
    if (has_nbaccesses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->nbaccesses());
    }
    
    // optional int64 atime = 4;
    if (has_atime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->atime());
    }
    
    // optional int64 ptime = 5;
    if (has_ptime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->ptime());
    }
    
    // optional int64 ltime = 6;
    if (has_ltime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->ltime());
    }
    
    // optional string status = 7;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string type = 8;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string pool = 9;
    if (has_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pool());
    }
    
    // optional string server = 10;
    if (has_server()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server());
    }
    
    // optional string filesystem = 11;
    if (has_filesystem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filesystem());
    }
    
    // optional string url = 12;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialReplica::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialReplica* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialReplica*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialReplica::MergeFrom(const SerialReplica& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_replicaid(from.replicaid());
    }
    if (from._has_bit(1)) {
      set_fileid(from.fileid());
    }
    if (from._has_bit(2)) {
      set_nbaccesses(from.nbaccesses());
    }
    if (from._has_bit(3)) {
      set_atime(from.atime());
    }
    if (from._has_bit(4)) {
      set_ptime(from.ptime());
    }
    if (from._has_bit(5)) {
      set_ltime(from.ltime());
    }
    if (from._has_bit(6)) {
      set_status(from.status());
    }
    if (from._has_bit(7)) {
      set_type(from.type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_pool(from.pool());
    }
    if (from._has_bit(9)) {
      set_server(from.server());
    }
    if (from._has_bit(10)) {
      set_filesystem(from.filesystem());
    }
    if (from._has_bit(11)) {
      set_url(from.url());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialReplica::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialReplica::CopyFrom(const SerialReplica& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialReplica::IsInitialized() const {
  
  return true;
}

void SerialReplica::Swap(SerialReplica* other) {
  if (other != this) {
    std::swap(replicaid_, other->replicaid_);
    std::swap(fileid_, other->fileid_);
    std::swap(nbaccesses_, other->nbaccesses_);
    std::swap(atime_, other->atime_);
    std::swap(ptime_, other->ptime_);
    std::swap(ltime_, other->ltime_);
    std::swap(status_, other->status_);
    std::swap(type_, other->type_);
    std::swap(pool_, other->pool_);
    std::swap(server_, other->server_);
    std::swap(filesystem_, other->filesystem_);
    std::swap(url_, other->url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialReplica::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialReplica_descriptor_;
  metadata.reflection = SerialReplica_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dmlite

// @@protoc_insertion_point(global_scope)
