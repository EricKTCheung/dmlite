// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MemcacheCatalog.proto

#ifndef PROTOBUF_MemcacheCatalog_2eproto__INCLUDED
#define PROTOBUF_MemcacheCatalog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace dmlite {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MemcacheCatalog_2eproto();
void protobuf_AssignDesc_MemcacheCatalog_2eproto();
void protobuf_ShutdownFile_MemcacheCatalog_2eproto();

class SerialExtendedStat;
class SerialStat;
class SerialSymLink;
class SerialComment;
class SerialKeyList;
class SerialKey;
class SerialReplicaList;
class SerialReplica;

enum CacheState {
  MISSING = 0,
  INVALID = 1,
  VALID = 2
};
bool CacheState_IsValid(int value);
const CacheState CacheState_MIN = MISSING;
const CacheState CacheState_MAX = VALID;
const int CacheState_ARRAYSIZE = CacheState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CacheState_descriptor();
inline const ::std::string& CacheState_Name(CacheState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CacheState_descriptor(), value);
}
inline bool CacheState_Parse(
    const ::std::string& name, CacheState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CacheState>(
    CacheState_descriptor(), name, value);
}
// ===================================================================

class SerialExtendedStat : public ::google::protobuf::Message {
 public:
  SerialExtendedStat();
  virtual ~SerialExtendedStat();
  
  SerialExtendedStat(const SerialExtendedStat& from);
  
  inline SerialExtendedStat& operator=(const SerialExtendedStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialExtendedStat& default_instance();
  
  void Swap(SerialExtendedStat* other);
  
  // implements Message ----------------------------------------------
  
  SerialExtendedStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialExtendedStat& from);
  void MergeFrom(const SerialExtendedStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .dmlite.SerialStat stat = 1;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 1;
  inline const ::dmlite::SerialStat& stat() const;
  inline ::dmlite::SerialStat* mutable_stat();
  
  // optional int32 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::int32 parent() const;
  inline void set_parent(::google::protobuf::int32 value);
  
  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  
  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string guid = 6;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 6;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  
  // optional string csumtype = 7;
  inline bool has_csumtype() const;
  inline void clear_csumtype();
  static const int kCsumtypeFieldNumber = 7;
  inline const ::std::string& csumtype() const;
  inline void set_csumtype(const ::std::string& value);
  inline void set_csumtype(const char* value);
  inline void set_csumtype(const char* value, size_t size);
  inline ::std::string* mutable_csumtype();
  
  // optional string csumvalue = 8;
  inline bool has_csumvalue() const;
  inline void clear_csumvalue();
  static const int kCsumvalueFieldNumber = 8;
  inline const ::std::string& csumvalue() const;
  inline void set_csumvalue(const ::std::string& value);
  inline void set_csumvalue(const char* value);
  inline void set_csumvalue(const char* value, size_t size);
  inline ::std::string* mutable_csumvalue();
  
  // optional string acl = 9;
  inline bool has_acl() const;
  inline void clear_acl();
  static const int kAclFieldNumber = 9;
  inline const ::std::string& acl() const;
  inline void set_acl(const ::std::string& value);
  inline void set_acl(const char* value);
  inline void set_acl(const char* value, size_t size);
  inline ::std::string* mutable_acl();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialExtendedStat)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::dmlite::SerialStat* stat_;
  ::google::protobuf::int32 parent_;
  ::google::protobuf::int32 type_;
  ::std::string* status_;
  static const ::std::string _default_status_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* guid_;
  static const ::std::string _default_guid_;
  ::std::string* csumtype_;
  static const ::std::string _default_csumtype_;
  ::std::string* csumvalue_;
  static const ::std::string _default_csumvalue_;
  ::std::string* acl_;
  static const ::std::string _default_acl_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialExtendedStat* default_instance_;
};
// -------------------------------------------------------------------

class SerialStat : public ::google::protobuf::Message {
 public:
  SerialStat();
  virtual ~SerialStat();
  
  SerialStat(const SerialStat& from);
  
  inline SerialStat& operator=(const SerialStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialStat& default_instance();
  
  void Swap(SerialStat* other);
  
  // implements Message ----------------------------------------------
  
  SerialStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialStat& from);
  void MergeFrom(const SerialStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 st_dev = 1;
  inline bool has_st_dev() const;
  inline void clear_st_dev();
  static const int kStDevFieldNumber = 1;
  inline ::google::protobuf::int32 st_dev() const;
  inline void set_st_dev(::google::protobuf::int32 value);
  
  // optional int32 st_ino = 2;
  inline bool has_st_ino() const;
  inline void clear_st_ino();
  static const int kStInoFieldNumber = 2;
  inline ::google::protobuf::int32 st_ino() const;
  inline void set_st_ino(::google::protobuf::int32 value);
  
  // optional int32 st_mode = 3;
  inline bool has_st_mode() const;
  inline void clear_st_mode();
  static const int kStModeFieldNumber = 3;
  inline ::google::protobuf::int32 st_mode() const;
  inline void set_st_mode(::google::protobuf::int32 value);
  
  // optional int32 st_nlink = 4;
  inline bool has_st_nlink() const;
  inline void clear_st_nlink();
  static const int kStNlinkFieldNumber = 4;
  inline ::google::protobuf::int32 st_nlink() const;
  inline void set_st_nlink(::google::protobuf::int32 value);
  
  // optional int32 st_uid = 5;
  inline bool has_st_uid() const;
  inline void clear_st_uid();
  static const int kStUidFieldNumber = 5;
  inline ::google::protobuf::int32 st_uid() const;
  inline void set_st_uid(::google::protobuf::int32 value);
  
  // optional int32 st_gid = 6;
  inline bool has_st_gid() const;
  inline void clear_st_gid();
  static const int kStGidFieldNumber = 6;
  inline ::google::protobuf::int32 st_gid() const;
  inline void set_st_gid(::google::protobuf::int32 value);
  
  // optional int32 st_rdev = 7;
  inline bool has_st_rdev() const;
  inline void clear_st_rdev();
  static const int kStRdevFieldNumber = 7;
  inline ::google::protobuf::int32 st_rdev() const;
  inline void set_st_rdev(::google::protobuf::int32 value);
  
  // optional int32 st_size = 8;
  inline bool has_st_size() const;
  inline void clear_st_size();
  static const int kStSizeFieldNumber = 8;
  inline ::google::protobuf::int32 st_size() const;
  inline void set_st_size(::google::protobuf::int32 value);
  
  // optional int64 st_access_time = 9;
  inline bool has_st_access_time() const;
  inline void clear_st_access_time();
  static const int kStAccessTimeFieldNumber = 9;
  inline ::google::protobuf::int64 st_access_time() const;
  inline void set_st_access_time(::google::protobuf::int64 value);
  
  // optional int64 st_modified_time = 10;
  inline bool has_st_modified_time() const;
  inline void clear_st_modified_time();
  static const int kStModifiedTimeFieldNumber = 10;
  inline ::google::protobuf::int64 st_modified_time() const;
  inline void set_st_modified_time(::google::protobuf::int64 value);
  
  // optional int64 st_change_time = 11;
  inline bool has_st_change_time() const;
  inline void clear_st_change_time();
  static const int kStChangeTimeFieldNumber = 11;
  inline ::google::protobuf::int64 st_change_time() const;
  inline void set_st_change_time(::google::protobuf::int64 value);
  
  // optional int32 st_blksize = 12;
  inline bool has_st_blksize() const;
  inline void clear_st_blksize();
  static const int kStBlksizeFieldNumber = 12;
  inline ::google::protobuf::int32 st_blksize() const;
  inline void set_st_blksize(::google::protobuf::int32 value);
  
  // optional int32 st_blocks = 13;
  inline bool has_st_blocks() const;
  inline void clear_st_blocks();
  static const int kStBlocksFieldNumber = 13;
  inline ::google::protobuf::int32 st_blocks() const;
  inline void set_st_blocks(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialStat)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 st_dev_;
  ::google::protobuf::int32 st_ino_;
  ::google::protobuf::int32 st_mode_;
  ::google::protobuf::int32 st_nlink_;
  ::google::protobuf::int32 st_uid_;
  ::google::protobuf::int32 st_gid_;
  ::google::protobuf::int32 st_rdev_;
  ::google::protobuf::int32 st_size_;
  ::google::protobuf::int64 st_access_time_;
  ::google::protobuf::int64 st_modified_time_;
  ::google::protobuf::int64 st_change_time_;
  ::google::protobuf::int32 st_blksize_;
  ::google::protobuf::int32 st_blocks_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialStat* default_instance_;
};
// -------------------------------------------------------------------

class SerialSymLink : public ::google::protobuf::Message {
 public:
  SerialSymLink();
  virtual ~SerialSymLink();
  
  SerialSymLink(const SerialSymLink& from);
  
  inline SerialSymLink& operator=(const SerialSymLink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialSymLink& default_instance();
  
  void Swap(SerialSymLink* other);
  
  // implements Message ----------------------------------------------
  
  SerialSymLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialSymLink& from);
  void MergeFrom(const SerialSymLink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 fileid = 1;
  inline bool has_fileid() const;
  inline void clear_fileid();
  static const int kFileidFieldNumber = 1;
  inline ::google::protobuf::int32 fileid() const;
  inline void set_fileid(::google::protobuf::int32 value);
  
  // optional string link = 2;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 2;
  inline const ::std::string& link() const;
  inline void set_link(const ::std::string& value);
  inline void set_link(const char* value);
  inline void set_link(const char* value, size_t size);
  inline ::std::string* mutable_link();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialSymLink)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 fileid_;
  ::std::string* link_;
  static const ::std::string _default_link_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialSymLink* default_instance_;
};
// -------------------------------------------------------------------

class SerialComment : public ::google::protobuf::Message {
 public:
  SerialComment();
  virtual ~SerialComment();
  
  SerialComment(const SerialComment& from);
  
  inline SerialComment& operator=(const SerialComment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialComment& default_instance();
  
  void Swap(SerialComment* other);
  
  // implements Message ----------------------------------------------
  
  SerialComment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialComment& from);
  void MergeFrom(const SerialComment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string comment = 1;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 1;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialComment)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* comment_;
  static const ::std::string _default_comment_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialComment* default_instance_;
};
// -------------------------------------------------------------------

class SerialKeyList : public ::google::protobuf::Message {
 public:
  SerialKeyList();
  virtual ~SerialKeyList();
  
  SerialKeyList(const SerialKeyList& from);
  
  inline SerialKeyList& operator=(const SerialKeyList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialKeyList& default_instance();
  
  void Swap(SerialKeyList* other);
  
  // implements Message ----------------------------------------------
  
  SerialKeyList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialKeyList& from);
  void MergeFrom(const SerialKeyList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dmlite.CacheState state = 2 [default = MISSING];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline dmlite::CacheState state() const;
  inline void set_state(dmlite::CacheState value);
  
  // repeated .dmlite.SerialKey key = 1;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::dmlite::SerialKey& key(int index) const;
  inline ::dmlite::SerialKey* mutable_key(int index);
  inline ::dmlite::SerialKey* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::dmlite::SerialKey >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::dmlite::SerialKey >*
      mutable_key();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialKeyList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int state_;
  ::google::protobuf::RepeatedPtrField< ::dmlite::SerialKey > key_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialKeyList* default_instance_;
};
// -------------------------------------------------------------------

class SerialKey : public ::google::protobuf::Message {
 public:
  SerialKey();
  virtual ~SerialKey();
  
  SerialKey(const SerialKey& from);
  
  inline SerialKey& operator=(const SerialKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialKey& default_instance();
  
  void Swap(SerialKey* other);
  
  // implements Message ----------------------------------------------
  
  SerialKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialKey& from);
  void MergeFrom(const SerialKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialKey)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialKey* default_instance_;
};
// -------------------------------------------------------------------

class SerialReplicaList : public ::google::protobuf::Message {
 public:
  SerialReplicaList();
  virtual ~SerialReplicaList();
  
  SerialReplicaList(const SerialReplicaList& from);
  
  inline SerialReplicaList& operator=(const SerialReplicaList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialReplicaList& default_instance();
  
  void Swap(SerialReplicaList* other);
  
  // implements Message ----------------------------------------------
  
  SerialReplicaList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialReplicaList& from);
  void MergeFrom(const SerialReplicaList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .dmlite.SerialReplica replica = 1;
  inline int replica_size() const;
  inline void clear_replica();
  static const int kReplicaFieldNumber = 1;
  inline const ::dmlite::SerialReplica& replica(int index) const;
  inline ::dmlite::SerialReplica* mutable_replica(int index);
  inline ::dmlite::SerialReplica* add_replica();
  inline const ::google::protobuf::RepeatedPtrField< ::dmlite::SerialReplica >&
      replica() const;
  inline ::google::protobuf::RepeatedPtrField< ::dmlite::SerialReplica >*
      mutable_replica();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialReplicaList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::dmlite::SerialReplica > replica_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialReplicaList* default_instance_;
};
// -------------------------------------------------------------------

class SerialReplica : public ::google::protobuf::Message {
 public:
  SerialReplica();
  virtual ~SerialReplica();
  
  SerialReplica(const SerialReplica& from);
  
  inline SerialReplica& operator=(const SerialReplica& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialReplica& default_instance();
  
  void Swap(SerialReplica* other);
  
  // implements Message ----------------------------------------------
  
  SerialReplica* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialReplica& from);
  void MergeFrom(const SerialReplica& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 replicaid = 1;
  inline bool has_replicaid() const;
  inline void clear_replicaid();
  static const int kReplicaidFieldNumber = 1;
  inline ::google::protobuf::int64 replicaid() const;
  inline void set_replicaid(::google::protobuf::int64 value);
  
  // optional int64 fileid = 2;
  inline bool has_fileid() const;
  inline void clear_fileid();
  static const int kFileidFieldNumber = 2;
  inline ::google::protobuf::int64 fileid() const;
  inline void set_fileid(::google::protobuf::int64 value);
  
  // optional int64 nbaccesses = 3;
  inline bool has_nbaccesses() const;
  inline void clear_nbaccesses();
  static const int kNbaccessesFieldNumber = 3;
  inline ::google::protobuf::int64 nbaccesses() const;
  inline void set_nbaccesses(::google::protobuf::int64 value);
  
  // optional int64 atime = 4;
  inline bool has_atime() const;
  inline void clear_atime();
  static const int kAtimeFieldNumber = 4;
  inline ::google::protobuf::int64 atime() const;
  inline void set_atime(::google::protobuf::int64 value);
  
  // optional int64 ptime = 5;
  inline bool has_ptime() const;
  inline void clear_ptime();
  static const int kPtimeFieldNumber = 5;
  inline ::google::protobuf::int64 ptime() const;
  inline void set_ptime(::google::protobuf::int64 value);
  
  // optional int64 ltime = 6;
  inline bool has_ltime() const;
  inline void clear_ltime();
  static const int kLtimeFieldNumber = 6;
  inline ::google::protobuf::int64 ltime() const;
  inline void set_ltime(::google::protobuf::int64 value);
  
  // optional string status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  
  // optional string type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional string pool = 9;
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 9;
  inline const ::std::string& pool() const;
  inline void set_pool(const ::std::string& value);
  inline void set_pool(const char* value);
  inline void set_pool(const char* value, size_t size);
  inline ::std::string* mutable_pool();
  
  // optional string server = 10;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 10;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  
  // optional string filesystem = 11;
  inline bool has_filesystem() const;
  inline void clear_filesystem();
  static const int kFilesystemFieldNumber = 11;
  inline const ::std::string& filesystem() const;
  inline void set_filesystem(const ::std::string& value);
  inline void set_filesystem(const char* value);
  inline void set_filesystem(const char* value, size_t size);
  inline ::std::string* mutable_filesystem();
  
  // optional string url = 12;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 12;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  
  // @@protoc_insertion_point(class_scope:dmlite.SerialReplica)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 replicaid_;
  ::google::protobuf::int64 fileid_;
  ::google::protobuf::int64 nbaccesses_;
  ::google::protobuf::int64 atime_;
  ::google::protobuf::int64 ptime_;
  ::google::protobuf::int64 ltime_;
  ::std::string* status_;
  static const ::std::string _default_status_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::std::string* pool_;
  static const ::std::string _default_pool_;
  ::std::string* server_;
  static const ::std::string _default_server_;
  ::std::string* filesystem_;
  static const ::std::string _default_filesystem_;
  ::std::string* url_;
  static const ::std::string _default_url_;
  friend void  protobuf_AddDesc_MemcacheCatalog_2eproto();
  friend void protobuf_AssignDesc_MemcacheCatalog_2eproto();
  friend void protobuf_ShutdownFile_MemcacheCatalog_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SerialReplica* default_instance_;
};
// ===================================================================


// ===================================================================

// SerialExtendedStat

// optional .dmlite.SerialStat stat = 1;
inline bool SerialExtendedStat::has_stat() const {
  return _has_bit(0);
}
inline void SerialExtendedStat::clear_stat() {
  if (stat_ != NULL) stat_->::dmlite::SerialStat::Clear();
  _clear_bit(0);
}
inline const ::dmlite::SerialStat& SerialExtendedStat::stat() const {
  return stat_ != NULL ? *stat_ : *default_instance_->stat_;
}
inline ::dmlite::SerialStat* SerialExtendedStat::mutable_stat() {
  _set_bit(0);
  if (stat_ == NULL) stat_ = new ::dmlite::SerialStat;
  return stat_;
}

// optional int32 parent = 2;
inline bool SerialExtendedStat::has_parent() const {
  return _has_bit(1);
}
inline void SerialExtendedStat::clear_parent() {
  parent_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 SerialExtendedStat::parent() const {
  return parent_;
}
inline void SerialExtendedStat::set_parent(::google::protobuf::int32 value) {
  _set_bit(1);
  parent_ = value;
}

// optional int32 type = 3;
inline bool SerialExtendedStat::has_type() const {
  return _has_bit(2);
}
inline void SerialExtendedStat::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 SerialExtendedStat::type() const {
  return type_;
}
inline void SerialExtendedStat::set_type(::google::protobuf::int32 value) {
  _set_bit(2);
  type_ = value;
}

// optional string status = 4;
inline bool SerialExtendedStat::has_status() const {
  return _has_bit(3);
}
inline void SerialExtendedStat::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& SerialExtendedStat::status() const {
  return *status_;
}
inline void SerialExtendedStat::set_status(const ::std::string& value) {
  _set_bit(3);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SerialExtendedStat::set_status(const char* value) {
  _set_bit(3);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SerialExtendedStat::set_status(const char* value, size_t size) {
  _set_bit(3);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_status() {
  _set_bit(3);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// optional string name = 5;
inline bool SerialExtendedStat::has_name() const {
  return _has_bit(4);
}
inline void SerialExtendedStat::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& SerialExtendedStat::name() const {
  return *name_;
}
inline void SerialExtendedStat::set_name(const ::std::string& value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SerialExtendedStat::set_name(const char* value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SerialExtendedStat::set_name(const char* value, size_t size) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_name() {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string guid = 6;
inline bool SerialExtendedStat::has_guid() const {
  return _has_bit(5);
}
inline void SerialExtendedStat::clear_guid() {
  if (guid_ != &_default_guid_) {
    guid_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& SerialExtendedStat::guid() const {
  return *guid_;
}
inline void SerialExtendedStat::set_guid(const ::std::string& value) {
  _set_bit(5);
  if (guid_ == &_default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void SerialExtendedStat::set_guid(const char* value) {
  _set_bit(5);
  if (guid_ == &_default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void SerialExtendedStat::set_guid(const char* value, size_t size) {
  _set_bit(5);
  if (guid_ == &_default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_guid() {
  _set_bit(5);
  if (guid_ == &_default_guid_) {
    guid_ = new ::std::string;
  }
  return guid_;
}

// optional string csumtype = 7;
inline bool SerialExtendedStat::has_csumtype() const {
  return _has_bit(6);
}
inline void SerialExtendedStat::clear_csumtype() {
  if (csumtype_ != &_default_csumtype_) {
    csumtype_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SerialExtendedStat::csumtype() const {
  return *csumtype_;
}
inline void SerialExtendedStat::set_csumtype(const ::std::string& value) {
  _set_bit(6);
  if (csumtype_ == &_default_csumtype_) {
    csumtype_ = new ::std::string;
  }
  csumtype_->assign(value);
}
inline void SerialExtendedStat::set_csumtype(const char* value) {
  _set_bit(6);
  if (csumtype_ == &_default_csumtype_) {
    csumtype_ = new ::std::string;
  }
  csumtype_->assign(value);
}
inline void SerialExtendedStat::set_csumtype(const char* value, size_t size) {
  _set_bit(6);
  if (csumtype_ == &_default_csumtype_) {
    csumtype_ = new ::std::string;
  }
  csumtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_csumtype() {
  _set_bit(6);
  if (csumtype_ == &_default_csumtype_) {
    csumtype_ = new ::std::string;
  }
  return csumtype_;
}

// optional string csumvalue = 8;
inline bool SerialExtendedStat::has_csumvalue() const {
  return _has_bit(7);
}
inline void SerialExtendedStat::clear_csumvalue() {
  if (csumvalue_ != &_default_csumvalue_) {
    csumvalue_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& SerialExtendedStat::csumvalue() const {
  return *csumvalue_;
}
inline void SerialExtendedStat::set_csumvalue(const ::std::string& value) {
  _set_bit(7);
  if (csumvalue_ == &_default_csumvalue_) {
    csumvalue_ = new ::std::string;
  }
  csumvalue_->assign(value);
}
inline void SerialExtendedStat::set_csumvalue(const char* value) {
  _set_bit(7);
  if (csumvalue_ == &_default_csumvalue_) {
    csumvalue_ = new ::std::string;
  }
  csumvalue_->assign(value);
}
inline void SerialExtendedStat::set_csumvalue(const char* value, size_t size) {
  _set_bit(7);
  if (csumvalue_ == &_default_csumvalue_) {
    csumvalue_ = new ::std::string;
  }
  csumvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_csumvalue() {
  _set_bit(7);
  if (csumvalue_ == &_default_csumvalue_) {
    csumvalue_ = new ::std::string;
  }
  return csumvalue_;
}

// optional string acl = 9;
inline bool SerialExtendedStat::has_acl() const {
  return _has_bit(8);
}
inline void SerialExtendedStat::clear_acl() {
  if (acl_ != &_default_acl_) {
    acl_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& SerialExtendedStat::acl() const {
  return *acl_;
}
inline void SerialExtendedStat::set_acl(const ::std::string& value) {
  _set_bit(8);
  if (acl_ == &_default_acl_) {
    acl_ = new ::std::string;
  }
  acl_->assign(value);
}
inline void SerialExtendedStat::set_acl(const char* value) {
  _set_bit(8);
  if (acl_ == &_default_acl_) {
    acl_ = new ::std::string;
  }
  acl_->assign(value);
}
inline void SerialExtendedStat::set_acl(const char* value, size_t size) {
  _set_bit(8);
  if (acl_ == &_default_acl_) {
    acl_ = new ::std::string;
  }
  acl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialExtendedStat::mutable_acl() {
  _set_bit(8);
  if (acl_ == &_default_acl_) {
    acl_ = new ::std::string;
  }
  return acl_;
}

// -------------------------------------------------------------------

// SerialStat

// optional int32 st_dev = 1;
inline bool SerialStat::has_st_dev() const {
  return _has_bit(0);
}
inline void SerialStat::clear_st_dev() {
  st_dev_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SerialStat::st_dev() const {
  return st_dev_;
}
inline void SerialStat::set_st_dev(::google::protobuf::int32 value) {
  _set_bit(0);
  st_dev_ = value;
}

// optional int32 st_ino = 2;
inline bool SerialStat::has_st_ino() const {
  return _has_bit(1);
}
inline void SerialStat::clear_st_ino() {
  st_ino_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 SerialStat::st_ino() const {
  return st_ino_;
}
inline void SerialStat::set_st_ino(::google::protobuf::int32 value) {
  _set_bit(1);
  st_ino_ = value;
}

// optional int32 st_mode = 3;
inline bool SerialStat::has_st_mode() const {
  return _has_bit(2);
}
inline void SerialStat::clear_st_mode() {
  st_mode_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 SerialStat::st_mode() const {
  return st_mode_;
}
inline void SerialStat::set_st_mode(::google::protobuf::int32 value) {
  _set_bit(2);
  st_mode_ = value;
}

// optional int32 st_nlink = 4;
inline bool SerialStat::has_st_nlink() const {
  return _has_bit(3);
}
inline void SerialStat::clear_st_nlink() {
  st_nlink_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 SerialStat::st_nlink() const {
  return st_nlink_;
}
inline void SerialStat::set_st_nlink(::google::protobuf::int32 value) {
  _set_bit(3);
  st_nlink_ = value;
}

// optional int32 st_uid = 5;
inline bool SerialStat::has_st_uid() const {
  return _has_bit(4);
}
inline void SerialStat::clear_st_uid() {
  st_uid_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 SerialStat::st_uid() const {
  return st_uid_;
}
inline void SerialStat::set_st_uid(::google::protobuf::int32 value) {
  _set_bit(4);
  st_uid_ = value;
}

// optional int32 st_gid = 6;
inline bool SerialStat::has_st_gid() const {
  return _has_bit(5);
}
inline void SerialStat::clear_st_gid() {
  st_gid_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 SerialStat::st_gid() const {
  return st_gid_;
}
inline void SerialStat::set_st_gid(::google::protobuf::int32 value) {
  _set_bit(5);
  st_gid_ = value;
}

// optional int32 st_rdev = 7;
inline bool SerialStat::has_st_rdev() const {
  return _has_bit(6);
}
inline void SerialStat::clear_st_rdev() {
  st_rdev_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 SerialStat::st_rdev() const {
  return st_rdev_;
}
inline void SerialStat::set_st_rdev(::google::protobuf::int32 value) {
  _set_bit(6);
  st_rdev_ = value;
}

// optional int32 st_size = 8;
inline bool SerialStat::has_st_size() const {
  return _has_bit(7);
}
inline void SerialStat::clear_st_size() {
  st_size_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 SerialStat::st_size() const {
  return st_size_;
}
inline void SerialStat::set_st_size(::google::protobuf::int32 value) {
  _set_bit(7);
  st_size_ = value;
}

// optional int64 st_access_time = 9;
inline bool SerialStat::has_st_access_time() const {
  return _has_bit(8);
}
inline void SerialStat::clear_st_access_time() {
  st_access_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(8);
}
inline ::google::protobuf::int64 SerialStat::st_access_time() const {
  return st_access_time_;
}
inline void SerialStat::set_st_access_time(::google::protobuf::int64 value) {
  _set_bit(8);
  st_access_time_ = value;
}

// optional int64 st_modified_time = 10;
inline bool SerialStat::has_st_modified_time() const {
  return _has_bit(9);
}
inline void SerialStat::clear_st_modified_time() {
  st_modified_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(9);
}
inline ::google::protobuf::int64 SerialStat::st_modified_time() const {
  return st_modified_time_;
}
inline void SerialStat::set_st_modified_time(::google::protobuf::int64 value) {
  _set_bit(9);
  st_modified_time_ = value;
}

// optional int64 st_change_time = 11;
inline bool SerialStat::has_st_change_time() const {
  return _has_bit(10);
}
inline void SerialStat::clear_st_change_time() {
  st_change_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(10);
}
inline ::google::protobuf::int64 SerialStat::st_change_time() const {
  return st_change_time_;
}
inline void SerialStat::set_st_change_time(::google::protobuf::int64 value) {
  _set_bit(10);
  st_change_time_ = value;
}

// optional int32 st_blksize = 12;
inline bool SerialStat::has_st_blksize() const {
  return _has_bit(11);
}
inline void SerialStat::clear_st_blksize() {
  st_blksize_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 SerialStat::st_blksize() const {
  return st_blksize_;
}
inline void SerialStat::set_st_blksize(::google::protobuf::int32 value) {
  _set_bit(11);
  st_blksize_ = value;
}

// optional int32 st_blocks = 13;
inline bool SerialStat::has_st_blocks() const {
  return _has_bit(12);
}
inline void SerialStat::clear_st_blocks() {
  st_blocks_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 SerialStat::st_blocks() const {
  return st_blocks_;
}
inline void SerialStat::set_st_blocks(::google::protobuf::int32 value) {
  _set_bit(12);
  st_blocks_ = value;
}

// -------------------------------------------------------------------

// SerialSymLink

// optional int32 fileid = 1;
inline bool SerialSymLink::has_fileid() const {
  return _has_bit(0);
}
inline void SerialSymLink::clear_fileid() {
  fileid_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SerialSymLink::fileid() const {
  return fileid_;
}
inline void SerialSymLink::set_fileid(::google::protobuf::int32 value) {
  _set_bit(0);
  fileid_ = value;
}

// optional string link = 2;
inline bool SerialSymLink::has_link() const {
  return _has_bit(1);
}
inline void SerialSymLink::clear_link() {
  if (link_ != &_default_link_) {
    link_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SerialSymLink::link() const {
  return *link_;
}
inline void SerialSymLink::set_link(const ::std::string& value) {
  _set_bit(1);
  if (link_ == &_default_link_) {
    link_ = new ::std::string;
  }
  link_->assign(value);
}
inline void SerialSymLink::set_link(const char* value) {
  _set_bit(1);
  if (link_ == &_default_link_) {
    link_ = new ::std::string;
  }
  link_->assign(value);
}
inline void SerialSymLink::set_link(const char* value, size_t size) {
  _set_bit(1);
  if (link_ == &_default_link_) {
    link_ = new ::std::string;
  }
  link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialSymLink::mutable_link() {
  _set_bit(1);
  if (link_ == &_default_link_) {
    link_ = new ::std::string;
  }
  return link_;
}

// -------------------------------------------------------------------

// SerialComment

// optional string comment = 1;
inline bool SerialComment::has_comment() const {
  return _has_bit(0);
}
inline void SerialComment::clear_comment() {
  if (comment_ != &_default_comment_) {
    comment_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SerialComment::comment() const {
  return *comment_;
}
inline void SerialComment::set_comment(const ::std::string& value) {
  _set_bit(0);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SerialComment::set_comment(const char* value) {
  _set_bit(0);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SerialComment::set_comment(const char* value, size_t size) {
  _set_bit(0);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialComment::mutable_comment() {
  _set_bit(0);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  return comment_;
}

// -------------------------------------------------------------------

// SerialKeyList

// required .dmlite.CacheState state = 2 [default = MISSING];
inline bool SerialKeyList::has_state() const {
  return _has_bit(0);
}
inline void SerialKeyList::clear_state() {
  state_ = 0;
  _clear_bit(0);
}
inline dmlite::CacheState SerialKeyList::state() const {
  return static_cast< dmlite::CacheState >(state_);
}
inline void SerialKeyList::set_state(dmlite::CacheState value) {
  GOOGLE_DCHECK(dmlite::CacheState_IsValid(value));
  _set_bit(0);
  state_ = value;
}

// repeated .dmlite.SerialKey key = 1;
inline int SerialKeyList::key_size() const {
  return key_.size();
}
inline void SerialKeyList::clear_key() {
  key_.Clear();
}
inline const ::dmlite::SerialKey& SerialKeyList::key(int index) const {
  return key_.Get(index);
}
inline ::dmlite::SerialKey* SerialKeyList::mutable_key(int index) {
  return key_.Mutable(index);
}
inline ::dmlite::SerialKey* SerialKeyList::add_key() {
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dmlite::SerialKey >&
SerialKeyList::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::dmlite::SerialKey >*
SerialKeyList::mutable_key() {
  return &key_;
}

// -------------------------------------------------------------------

// SerialKey

// required string key = 1;
inline bool SerialKey::has_key() const {
  return _has_bit(0);
}
inline void SerialKey::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SerialKey::key() const {
  return *key_;
}
inline void SerialKey::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SerialKey::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SerialKey::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialKey::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// SerialReplicaList

// repeated .dmlite.SerialReplica replica = 1;
inline int SerialReplicaList::replica_size() const {
  return replica_.size();
}
inline void SerialReplicaList::clear_replica() {
  replica_.Clear();
}
inline const ::dmlite::SerialReplica& SerialReplicaList::replica(int index) const {
  return replica_.Get(index);
}
inline ::dmlite::SerialReplica* SerialReplicaList::mutable_replica(int index) {
  return replica_.Mutable(index);
}
inline ::dmlite::SerialReplica* SerialReplicaList::add_replica() {
  return replica_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dmlite::SerialReplica >&
SerialReplicaList::replica() const {
  return replica_;
}
inline ::google::protobuf::RepeatedPtrField< ::dmlite::SerialReplica >*
SerialReplicaList::mutable_replica() {
  return &replica_;
}

// -------------------------------------------------------------------

// SerialReplica

// optional int64 replicaid = 1;
inline bool SerialReplica::has_replicaid() const {
  return _has_bit(0);
}
inline void SerialReplica::clear_replicaid() {
  replicaid_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 SerialReplica::replicaid() const {
  return replicaid_;
}
inline void SerialReplica::set_replicaid(::google::protobuf::int64 value) {
  _set_bit(0);
  replicaid_ = value;
}

// optional int64 fileid = 2;
inline bool SerialReplica::has_fileid() const {
  return _has_bit(1);
}
inline void SerialReplica::clear_fileid() {
  fileid_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 SerialReplica::fileid() const {
  return fileid_;
}
inline void SerialReplica::set_fileid(::google::protobuf::int64 value) {
  _set_bit(1);
  fileid_ = value;
}

// optional int64 nbaccesses = 3;
inline bool SerialReplica::has_nbaccesses() const {
  return _has_bit(2);
}
inline void SerialReplica::clear_nbaccesses() {
  nbaccesses_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 SerialReplica::nbaccesses() const {
  return nbaccesses_;
}
inline void SerialReplica::set_nbaccesses(::google::protobuf::int64 value) {
  _set_bit(2);
  nbaccesses_ = value;
}

// optional int64 atime = 4;
inline bool SerialReplica::has_atime() const {
  return _has_bit(3);
}
inline void SerialReplica::clear_atime() {
  atime_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 SerialReplica::atime() const {
  return atime_;
}
inline void SerialReplica::set_atime(::google::protobuf::int64 value) {
  _set_bit(3);
  atime_ = value;
}

// optional int64 ptime = 5;
inline bool SerialReplica::has_ptime() const {
  return _has_bit(4);
}
inline void SerialReplica::clear_ptime() {
  ptime_ = GOOGLE_LONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::int64 SerialReplica::ptime() const {
  return ptime_;
}
inline void SerialReplica::set_ptime(::google::protobuf::int64 value) {
  _set_bit(4);
  ptime_ = value;
}

// optional int64 ltime = 6;
inline bool SerialReplica::has_ltime() const {
  return _has_bit(5);
}
inline void SerialReplica::clear_ltime() {
  ltime_ = GOOGLE_LONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::int64 SerialReplica::ltime() const {
  return ltime_;
}
inline void SerialReplica::set_ltime(::google::protobuf::int64 value) {
  _set_bit(5);
  ltime_ = value;
}

// optional string status = 7;
inline bool SerialReplica::has_status() const {
  return _has_bit(6);
}
inline void SerialReplica::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SerialReplica::status() const {
  return *status_;
}
inline void SerialReplica::set_status(const ::std::string& value) {
  _set_bit(6);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SerialReplica::set_status(const char* value) {
  _set_bit(6);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SerialReplica::set_status(const char* value, size_t size) {
  _set_bit(6);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_status() {
  _set_bit(6);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// optional string type = 8;
inline bool SerialReplica::has_type() const {
  return _has_bit(7);
}
inline void SerialReplica::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& SerialReplica::type() const {
  return *type_;
}
inline void SerialReplica::set_type(const ::std::string& value) {
  _set_bit(7);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SerialReplica::set_type(const char* value) {
  _set_bit(7);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SerialReplica::set_type(const char* value, size_t size) {
  _set_bit(7);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_type() {
  _set_bit(7);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional string pool = 9;
inline bool SerialReplica::has_pool() const {
  return _has_bit(8);
}
inline void SerialReplica::clear_pool() {
  if (pool_ != &_default_pool_) {
    pool_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& SerialReplica::pool() const {
  return *pool_;
}
inline void SerialReplica::set_pool(const ::std::string& value) {
  _set_bit(8);
  if (pool_ == &_default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void SerialReplica::set_pool(const char* value) {
  _set_bit(8);
  if (pool_ == &_default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void SerialReplica::set_pool(const char* value, size_t size) {
  _set_bit(8);
  if (pool_ == &_default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_pool() {
  _set_bit(8);
  if (pool_ == &_default_pool_) {
    pool_ = new ::std::string;
  }
  return pool_;
}

// optional string server = 10;
inline bool SerialReplica::has_server() const {
  return _has_bit(9);
}
inline void SerialReplica::clear_server() {
  if (server_ != &_default_server_) {
    server_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& SerialReplica::server() const {
  return *server_;
}
inline void SerialReplica::set_server(const ::std::string& value) {
  _set_bit(9);
  if (server_ == &_default_server_) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void SerialReplica::set_server(const char* value) {
  _set_bit(9);
  if (server_ == &_default_server_) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void SerialReplica::set_server(const char* value, size_t size) {
  _set_bit(9);
  if (server_ == &_default_server_) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_server() {
  _set_bit(9);
  if (server_ == &_default_server_) {
    server_ = new ::std::string;
  }
  return server_;
}

// optional string filesystem = 11;
inline bool SerialReplica::has_filesystem() const {
  return _has_bit(10);
}
inline void SerialReplica::clear_filesystem() {
  if (filesystem_ != &_default_filesystem_) {
    filesystem_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& SerialReplica::filesystem() const {
  return *filesystem_;
}
inline void SerialReplica::set_filesystem(const ::std::string& value) {
  _set_bit(10);
  if (filesystem_ == &_default_filesystem_) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(value);
}
inline void SerialReplica::set_filesystem(const char* value) {
  _set_bit(10);
  if (filesystem_ == &_default_filesystem_) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(value);
}
inline void SerialReplica::set_filesystem(const char* value, size_t size) {
  _set_bit(10);
  if (filesystem_ == &_default_filesystem_) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_filesystem() {
  _set_bit(10);
  if (filesystem_ == &_default_filesystem_) {
    filesystem_ = new ::std::string;
  }
  return filesystem_;
}

// optional string url = 12;
inline bool SerialReplica::has_url() const {
  return _has_bit(11);
}
inline void SerialReplica::clear_url() {
  if (url_ != &_default_url_) {
    url_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& SerialReplica::url() const {
  return *url_;
}
inline void SerialReplica::set_url(const ::std::string& value) {
  _set_bit(11);
  if (url_ == &_default_url_) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SerialReplica::set_url(const char* value) {
  _set_bit(11);
  if (url_ == &_default_url_) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SerialReplica::set_url(const char* value, size_t size) {
  _set_bit(11);
  if (url_ == &_default_url_) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialReplica::mutable_url() {
  _set_bit(11);
  if (url_ == &_default_url_) {
    url_ = new ::std::string;
  }
  return url_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dmlite

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dmlite::CacheState>() {
  return dmlite::CacheState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MemcacheCatalog_2eproto__INCLUDED
